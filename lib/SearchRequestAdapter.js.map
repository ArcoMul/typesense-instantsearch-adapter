{"version":3,"sources":["../src/SearchRequestAdapter.js"],"names":["SearchRequestAdapter","instantsearchRequests","typesenseClient","configuration","additionalSearchParameters","collectionSpecificSearchParameters","facetFilters","adaptedResult","transformedTypesenseFilters","map","item","Array","isArray","intermediateFacetFilters","forEach","facetFilter","facetFilterMatches","match","constructor","FILER_STRING_MATCHING_REGEX","fieldName","fieldValue","push","Object","keys","length","console","error","join","fieldValues","typesenseFilterString","_escapeFacetValue","value","numericFilters","filtersHash","filter","RegExp","field","operator","adaptedFilters","warn","JSON","stringify","insideBoundingBox","aroundRadius","aroundLatLng","x1","y1","x2","y2","flat","split","geoLocationField","Error","adaptedAroundRadius","parseFloat","instantsearchParams","_adaptFacetFilters","_adaptNumericFilters","_adaptGeoFilter","indexName","INDEX_NAME_MATCHING_REGEX","instantsearchRequest","params","adaptedCollectionName","_adaptIndexName","snakeCasedAdditionalSearchParameters","entries","key","_camelToSnakeCase","typesenseSearchParams","assign","adaptedSortBy","_adaptSortBy","collection","q","query","undefined","facet_by","facets","filter_by","_adaptFilters","sort_by","max_facet_values","maxValuesPerFacet","page","hitsPerPage","per_page","facetQuery","facet_query","facetName","str","toLowerCase","searches","_buildSearchParameters","multiSearch","perform"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexport class SearchRequestAdapter {\n  static get INDEX_NAME_MATCHING_REGEX() {\n    return new RegExp(\"^(.+?)(?=(/sort/(.*))|$)\");\n  }\n\n  static get FILER_STRING_MATCHING_REGEX() {\n    return new RegExp(\"(.*)((?!:).):(?!:)(.*)\");\n  }\n\n  constructor(instantsearchRequests, typesenseClient, configuration) {\n    this.instantsearchRequests = instantsearchRequests;\n    this.typesenseClient = typesenseClient;\n    this.configuration = configuration;\n    this.additionalSearchParameters = configuration.additionalSearchParameters;\n    this.collectionSpecificSearchParameters = configuration.collectionSpecificSearchParameters;\n  }\n\n  _adaptFacetFilters(facetFilters) {\n    let adaptedResult = \"\";\n\n    if (!facetFilters) {\n      return adaptedResult;\n    }\n\n    /**\n     * Need to transform:\n     *  facetFilters = [[\"field1:value1\", \"field1:value2\"], \"field2:value3\", \"field2:value4\"]\n     *\n     * Into this:\n     *  field1:=[value1,value2] && field2:=value3 && field2:=value4\n     *\n     * Steps:\n     *  - For each item in facetFilters\n     *    - If item is array\n     *      - OR values together.\n     *      - Warn if field names are not the same\n     *    - If item is string, convert to facet:=value format\n     *  - Join strings by &&\n     */\n\n    const transformedTypesenseFilters = facetFilters.map((item) => {\n      if (Array.isArray(item)) {\n        // Need to transform:\n        // facetFilters = [\"field1:value1\", \"field1:value2\", \"facetN:valueN\"]\n        //\n        // Into this:\n        // intermediateFacetFilters = {\n        //     \"field1\": [\"value1\", \"value2\"],\n        //     \"fieldN\": [\"valueN\"]\n        // }\n\n        const intermediateFacetFilters = {};\n        item.forEach((facetFilter) => {\n          const facetFilterMatches = facetFilter.match(this.constructor.FILER_STRING_MATCHING_REGEX);\n          const fieldName = `${facetFilterMatches[1]}${facetFilterMatches[2]}`;\n          const fieldValue = `${facetFilterMatches[3]}`;\n          intermediateFacetFilters[fieldName] = intermediateFacetFilters[fieldName] || [];\n          intermediateFacetFilters[fieldName].push(fieldValue);\n        });\n\n        if (Object.keys(intermediateFacetFilters).length > 1) {\n          console.error(\n            `[Typesense-Instantsearch-Adapter] Typesense does not support cross-field ORs at the moment. The adapter could not OR values between these fields: ${Object.keys(\n              intermediateFacetFilters\n            ).join(\",\")}`\n          );\n        }\n\n        // Pick first value from intermediateFacetFilters\n        const fieldName = Object.keys(intermediateFacetFilters)[0];\n        const fieldValues = intermediateFacetFilters[fieldName];\n\n        // Need to transform:\n        // intermediateFacetFilters = {\n        //     \"field1\": [\"value1\", \"value2\"],\n        // }\n        //\n        // Into this:\n        // field1:=[value1,value2]\n\n        const typesenseFilterString = `${fieldName}:=[${fieldValues.map(this._escapeFacetValue).join(\",\")}]`;\n\n        return typesenseFilterString;\n      } else {\n        // Need to transform:\n        //  fieldName:fieldValue\n        // Into\n        //  fieldName:=fieldValue\n\n        const facetFilterMatches = item.match(this.constructor.FILER_STRING_MATCHING_REGEX);\n        const fieldName = `${facetFilterMatches[1]}${facetFilterMatches[2]}`;\n        const fieldValue = `${facetFilterMatches[3]}`;\n        const typesenseFilterString = `${fieldName}:=[${this._escapeFacetValue(fieldValue)}]`;\n\n        return typesenseFilterString;\n      }\n    });\n\n    adaptedResult = transformedTypesenseFilters.join(\" && \");\n    // console.log(`${JSON.stringify(facetFilters)} => ${adaptedResult}`);\n\n    return adaptedResult;\n  }\n\n  _escapeFacetValue(value) {\n    // Don't escape booleans\n    if (typeof value === \"boolean\" || value === \"true\" || value === \"false\") {\n      return value;\n    }\n    return `\\`${value}\\``;\n  }\n\n  _adaptNumericFilters(numericFilters) {\n    // Need to transform this:\n    // [\"field1<=634\", \"field1>=289\", \"field2<=5\", \"field3>=3\"]\n    // to:\n    // \"field1:=[634..289] && field2:<=5 && field3:>=3\"\n    let adaptedResult = \"\";\n\n    if (!numericFilters) {\n      return adaptedResult;\n    }\n\n    // Transform to intermediate structure:\n    // {\n    //   field1: {\n    //     \"<=\": 634,\n    //     \">=\": 289\n    //   },\n    //   field2: {\n    //     \"<=\": 5\n    //   },\n    //   field3: {\n    //     \">=\": 3\n    //   }\n    // };\n    const filtersHash = {};\n    numericFilters.forEach((filter) => {\n      const [, field, operator, value] = filter.match(new RegExp(\"(.*)(<=|>=|>|<|:)(.*)\"));\n      filtersHash[field] = filtersHash[field] || {};\n      filtersHash[field][operator] = value;\n    });\n\n    // Transform that to:\n    //  \"field1:=[634..289] && field2:<=5 && field3:>=3\"\n    const adaptedFilters = [];\n    Object.keys(filtersHash).forEach((field) => {\n      if (filtersHash[field][\"<=\"] != null && filtersHash[field][\">=\"] != null) {\n        adaptedFilters.push(`${field}:=[${filtersHash[field][\">=\"]}..${filtersHash[field][\"<=\"]}]`);\n      } else if (filtersHash[field][\"<=\"] != null) {\n        adaptedFilters.push(`${field}:<=${filtersHash[field][\"<=\"]}`);\n      } else if (filtersHash[field][\">=\"] != null) {\n        adaptedFilters.push(`${field}:>=${filtersHash[field][\">=\"]}`);\n      } else {\n        console.warn(\n          `[Typesense-Instantsearch-Adapter] Unsupported operator found ${JSON.stringify(filtersHash[field])}`\n        );\n      }\n    });\n\n    adaptedResult = adaptedFilters.join(\" && \");\n    return adaptedResult;\n  }\n\n  _adaptGeoFilter({ insideBoundingBox, aroundRadius, aroundLatLng }) {\n    // Give this parameter first priority if it exists, since\n    if (insideBoundingBox) {\n      let x1, y1, x2, y2;\n      if (Array.isArray(insideBoundingBox)) {\n        [x1, y1, x2, y2] = insideBoundingBox.flat();\n      } else {\n        [x1, y1, x2, y2] = insideBoundingBox.split(\",\");\n      }\n      return `${this.configuration.geoLocationField}:(${x1}, ${y1}, ${x1}, ${y2}, ${x2}, ${y2}, ${x2}, ${y1})`;\n    }\n\n    if (aroundLatLng || aroundRadius) {\n      if (!aroundRadius || aroundRadius === \"all\") {\n        throw new Error(\n          \"[Typesense-Instantsearch-Adapter] In Typesense, geo-filtering around a lat/lng also requires a numerical radius. \" +\n            \"So the `aroundRadius` parameter is required when `aroundLatLng` is used. \" +\n            \"If you intend to just geo-sort around a lat/long, you want to use the sortBy InstantSearch widget (or a virtual sortBy custom widget).\"\n        );\n      }\n      const adaptedAroundRadius = `${parseFloat(aroundRadius) / 1000} km`; // aroundRadius is in meters\n      return `${this.configuration.geoLocationField}:(${aroundLatLng}, ${adaptedAroundRadius})`;\n    }\n  }\n\n  _adaptFilters(instantsearchParams) {\n    const adaptedFilters = [];\n\n    adaptedFilters.push(this._adaptFacetFilters(instantsearchParams.facetFilters));\n    adaptedFilters.push(this._adaptNumericFilters(instantsearchParams.numericFilters));\n    adaptedFilters.push(this._adaptGeoFilter(instantsearchParams));\n\n    return adaptedFilters.filter((filter) => filter && filter !== \"\").join(\" && \");\n  }\n\n  _adaptIndexName(indexName) {\n    return indexName.match(this.constructor.INDEX_NAME_MATCHING_REGEX)[1];\n  }\n\n  _adaptSortBy(indexName) {\n    return indexName.match(this.constructor.INDEX_NAME_MATCHING_REGEX)[3];\n  }\n\n  _buildSearchParameters(instantsearchRequest) {\n    const params = instantsearchRequest.params;\n    const indexName = instantsearchRequest.indexName;\n    const adaptedCollectionName = this._adaptIndexName(indexName);\n\n    // Convert all common parameters to snake case\n    const snakeCasedAdditionalSearchParameters = {};\n    for (const [key, value] of Object.entries(this.additionalSearchParameters)) {\n      snakeCasedAdditionalSearchParameters[this._camelToSnakeCase(key)] = value;\n    }\n\n    // Override, collection specific parameters\n    if (this.collectionSpecificSearchParameters[adaptedCollectionName]) {\n      for (const [key, value] of Object.entries(this.collectionSpecificSearchParameters[adaptedCollectionName])) {\n        snakeCasedAdditionalSearchParameters[this._camelToSnakeCase(key)] = value;\n      }\n    }\n\n    const typesenseSearchParams = Object.assign({}, snakeCasedAdditionalSearchParameters);\n\n    const adaptedSortBy = this._adaptSortBy(indexName);\n\n    Object.assign(typesenseSearchParams, {\n      collection: adaptedCollectionName,\n      q: params.query === \"\" || params.query === undefined ? \"*\" : params.query,\n      facet_by: [params.facets].flat().join(\",\"),\n      filter_by: this._adaptFilters(params),\n      sort_by: adaptedSortBy || snakeCasedAdditionalSearchParameters.sort_by,\n      max_facet_values: params.maxValuesPerFacet,\n      page: (params.page || 0) + 1,\n    });\n\n    if (params.hitsPerPage) {\n      typesenseSearchParams.per_page = params.hitsPerPage;\n    }\n\n    if (params.facetQuery) {\n      typesenseSearchParams.facet_query = `${params.facetName}:${params.facetQuery}`;\n      typesenseSearchParams.per_page = 0;\n    }\n\n    // console.log(params);\n    // console.log(typesenseSearchParams);\n\n    return typesenseSearchParams;\n  }\n\n  _camelToSnakeCase(str) {\n    return str\n      .split(/(?=[A-Z])/)\n      .join(\"_\")\n      .toLowerCase();\n  }\n\n  async request() {\n    const searches = this.instantsearchRequests.map((instantsearchRequest) =>\n      this._buildSearchParameters(instantsearchRequest)\n    );\n\n    return this.typesenseClient.multiSearch.perform({ searches: searches });\n  }\n}\n"],"file":"SearchRequestAdapter.js"}